# 로그 분석 과정 정리

1. LogAnalysisScheduler (스케쥴링)

- @Scheduled에 따라 정해진 시간마다 analyzeErrorLogs() 실행

2. LogAnalysisManager (핵심 처리)

- @Async에 의해 logAnalysisTaskExcutor 스레드 풀의 스레드 중 하나가 할당되어 로직 실행
- LogMonitoringClient를 호출해서 해당 프로젝트의 서비스 목록과 각 서비스의 최근 3분간 에러 로그 조회
- 가져온 로그가 있다면 buildPrompt()를 통해 RAG에 보낼 프롬프트 문자열 생성
- LogAnalysisEndpointService를 통해 프로젝트에 설정된 LLM provider와 model 기본값 정보 조회
- LogAnalysisClient (Rag 서버)를 호출해서 로그 분석 요청
    - 논블로킹(Non-blocking) 방식으로 동작

3. 결과 처리 (Reactive Chain)
- LogAnalysisClient의 analyzeLogs는 Mono 반환
- .flapMap을 통해 Rag 서버로부터 성공적인 응답 받으면 saveHistoryAsync 호출
- saveHistoryAsync는 MonitoringHistoryService.saveHistory()를 Schedulers.boundedElastic() 스레드 풀에서 실행해서 DB 저장 수행. 
    - 논블로킹 방식으로 동작
- .subscribe()가 호출되어 전체 리액티브 스트림이 실행되고, 최종 성공 또는 실패 로그 남음.

## 스레드 풀

- logAnalysisTaskExecutor: @Async용. 로그 수집, 프롬프트 생성 등 작업 처리
- Schedulers.boundedElastic(): saveHistoryAsync에서 DB I/O 작업을 위해 사용되는 리액터의 스레드 풀